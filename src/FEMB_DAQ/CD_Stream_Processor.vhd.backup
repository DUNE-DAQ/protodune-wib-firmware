library ieee;
use ieee.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_misc.all;
use work.COLDATA_IO.all;
use work.FEMB_DAQ_IO.all;
use work.Convert_IO.all;
use work.CD_EB_BRIDGE.all;
use work.WIB_Constants.all;

entity CD_Stream_Processor is
  generic (
    IS_LINK_A : std_logic := '1');
  port (            
    --Data in (CD clock)
    clk_CD          : in std_logic;
    reset_CD        : in std_logic;
    COLDATA_stream  : in std_logic_vector(8 downto 0);
    convert         : in convert_t;

    --Data out (DAQ clock)
    clk_EVB         : in std_logic;
    reset_EVB       : in std_logic;
    --Per CD frame
    CD_to_EB_stream : out CD_Stream_t;    
    EB_rd           : in  std_logic;

    --Monitoring/control
    monitor         : out CD_Stream_Monitor_t;
    control         : in  CD_Stream_Control_t
    );  -- single COLDATA stream

end entity CD_Stream_Processor;

architecture behavioral of CD_Stream_Processor is


  signal reset_local      : std_logic := '1';
  signal reset_CD_local : std_logic := '1';
  signal reset_EVB_local  : std_logic := '1';
  
  component reseter is
    port (
      clk         : in  std_logic;
      reset_async : in  std_logic;
      reset_sync  : in  std_logic;
      reset       : out std_logic);
  end component reseter;
  
  component pacd is
    port (
      iPulseA : IN  std_logic;
      iClkA   : IN  std_logic;
      iRSTAn  : IN  std_logic;
      iClkB   : IN  std_logic;
      iRSTBn  : IN  std_logic;
      oPulseB : OUT std_logic);
  end component pacd;
  -------------------------------------------------------------------------------
  --Buffer RAM
  ------------------------------------------------------------------------------- 
  component CDRAM is
    port (
      data      : IN  STD_LOGIC_VECTOR (7 DOWNTO 0);
      rdaddress : IN  STD_LOGIC_VECTOR (7 DOWNTO 0);
      rdclock   : IN  STD_LOGIC;
      wraddress : IN  STD_LOGIC_VECTOR (9 DOWNTO 0);
      wrclock   : IN  STD_LOGIC := '1';
      wren      : IN  STD_LOGIC := '0';
      q         : OUT STD_LOGIC_VECTOR (31 DOWNTO 0));
  end component CDRAM;
  constant PAGE_COUNT : integer := 16; --4
  constant RD_page_DEFAULT : unsigned(3 downto 0) := "1111"; -- 11
  constant WR_page_DEFAULT : unsigned(3 downto 0) := "0000"; -- 00

  signal RD_page          : unsigned(3 downto 0) := RD_page_DEFAULT;
  signal RD_page_avail    : unsigned(3 downto 0) := RD_page_DEFAULT;
  signal WR_page          : unsigned(3 downto 0) := WR_page_DEFAULT;
  signal capture_domain_RD_page_copy : unsigned(3 downto 0) := RD_page_DEFAULT;
  signal readout_domain_WR_page_copy : unsigned(3 downto 0) := WR_page_DEFAULT;
  signal capture_domain_RD_page_update : std_logic := '0';
  signal readout_domain_RD_page_update : std_logic := '0';
  signal capture_domain_WR_page_update : std_logic := '0';
  signal readout_domain_WR_page_update : std_logic := '0';
  signal wr_page_update_done : std_logic := '0';
  
  signal rd_address       : unsigned(3 downto 0) := "0000";
  signal wr_address       : unsigned(5 downto 0) := ADDR_CHECKSUM_1;--"000000";
  signal data_out_address : std_logic_vector(7 downto 0) := "00000000";
  signal data_in_address  : std_logic_vector(9 downto 0) := "00"&x"00";
  
  signal data_in_wr      : std_logic := '0';
--  signal data_out_local  : std_logic_vector(15 downto 0) := (others => '0');


  signal word_number : unsigned(5 downto 0) := (others => '0');


  signal CD_delay  : std_logic_vector(8 downto 0);
  
  -------------------------------------------------------------------------------
  -- Convert trigger delay signals
  ------------------------------------------------------------------------------- 
  type convert_array_t is array (integer range PAGE_COUNT-1 downto 0) of convert_t;
  signal captured_convert : convert_array_t := (others => DEFAULT_CONVERT);
  
--  signal convert_delay : std_logic_vector(COLDATA_CONVERT_PERIOD_128MHZ downto 0) := (others => '0');
--  signal convert_buffer : convert_t;
--  signal convert_delayed : convert_t;
--  signal wait_window_counter : unsigned(7 downto 0) := x"00";
  
  -------------------------------------------------------------------------------
  -- Errors from captured data
  -------------------------------------------------------------------------------
  
  type byte_array_t is array (0 to PAGE_COUNT-1) of std_logic_vector(7 downto 0);
  signal data_errors : byte_array_t := (others => (others => '0'));
  constant ERR_NOT_FINISHED : integer := 0;
  constant ERR_BAD_SOF      : integer := 1;
  constant ERR_LARGE_FRAME  : integer := 2;
  constant ERR_K_IN_FRAME   : integer := 3;
  constant ERR_CHSUM_BAD    : integer := 7;
  type unsigned16_array_t is array (0 to PAGE_COUNT-1) of unsigned(15 downto 0);
  type uint16_array_t  is array (0 to PAGE_COUNT-1) of std_logic_vector(15 downto 0);
  signal running_checksum : unsigned(15 downto 0) := (others => '0');
  signal computed_checksum  : unsigned16_array_t := (others => (others => '0'));
  signal stream_checksum  : unsigned16_array_t := (others => (others => '0'));
  signal stream_timestamp : uint16_array_t := (others => (others => '0'));
  signal stream_errors    : uint16_array_t := (others => (others => '0'));
  -- Error counters
  component counter is
    generic (
      roll_over   : std_logic;
      end_value   : std_logic_vector;
      start_value : std_logic_vector;
      DATA_WIDTH  : integer);
    port (
      clk         : in  std_logic;
      reset_async : in  std_logic;
      reset_sync  : in  std_logic;
      enable      : in  std_logic;
      event       : in  std_logic;
      count       : out std_logic_vector(DATA_WIDTH-1 downto 0);
      at_max      : out std_logic);
  end component counter;
  -- Error pulses
  signal error_BUFFER_FULL : std_logic := '0';
  signal error_CONVERT_IN_WAIT_WINDOW : std_logic := '0';
  signal error_BAD_SOF  : std_logic := '0';
  signal error_UNEXPECTED_EOF  : std_logic := '0';
  signal error_MISSING_EOF  : std_logic := '0';
  signal error_KCHAR_IN_DATA  : std_logic := '0';
  signal error_BAD_CHSUM : std_logic := '0';
  signal pulse_packet_start : std_logic := '0';

  
  -------------------------------------------------------------------------------
  -- Capture state machine
  -------------------------------------------------------------------------------   
  type Capture_state_t is (CAP_STATE_IDLE,        --Wait for idles to finish
                                                  --and to get a new page
                           CAP_STATE_START,       --Wati ffor the first frame
                           CAP_STATE_SKIP_WORD,   -- Skip the word after the
                                                  -- SOF due to
                                                  -- miscommunication on the
                                                  -- FEMB firmware
                           CAP_STATE_INIT,        --Wait for and IDLE character
                                                  --to show we are locked
                           CAP_STATE_PROCESS,     --Process the incomming data
                           CAP_STATE_END          --This is the first word
                                                  --after the last word of
                                                  --frame data
                           );
  signal capture_state : capture_state_t := CAP_STATE_INIT;
  constant CAPTURE_IDLE_COUNT_START : integer range 8 downto 0 := 6;
  -- updating this value from 4 because of the variable number due to slips. 4;
  --New value of 4 is due to swap of one idle and SOF words in the FEMB. when this
  --is fixed switch back to 5--5;--8;
  signal capture_idle_count : integer range 8 downto 0 := CAPTURE_IDLE_COUNT_START;
  
  -------------------------------------------------------------------------------
  -- Capture state machine
  -------------------------------------------------------------------------------   
  type readout_state_t is (RDOUT_STATE_IDLE,       --Waiting for a new valid page
                           RDOUT_STATE_CHECKING, --Compare checksums
                           RDOUT_STATE_WAIT,     --Wait for read to start

                                                   --errors, set ready for reading
                           RDOUT_STATE_READING     --FIFO-like readout of raw data
                           );
  signal readout_state : readout_state_t := RDOUT_STATE_IDLE;
  signal wait_for_first_real_trigger : std_logic := '1';
  -------------------------------------------------------------------------------
  -- capture delay
  -------------------------------------------------------------------------------
  signal   send_startup_pulse : std_logic := '1';  
  signal   start_EVB_pulse_CDCLK : std_logic := '0';
  signal   start_EVB_pulse_EVBCLK : std_logic := '0';
  constant READOUT_DELAY_COUNTDOWN_START : unsigned(7 downto 0) := x"0f";
  signal   readout_delay_countdown : unsigned(7 downto 0) := READOUT_DELAY_COUNTDOWN_START;
  signal   enable_readout : std_logic := '0';

  
begin  -- architecture behavioral

  
  -------------------------------------------------------------------------------
  -- resets
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------

  --Since a reset on either end of this should reset the pages, we take the or
  --of the resets in each of the clock domains as an async reset that must be
  --properly propogated to each domain's sync reset.
  reset_local <= reset_CD or reset_EVB; --async
  
  reseter_1: entity work.reseter
    port map (
      clk         => clk_CD,
      reset_async => reset_local,
      reset_sync  => '0',
      reset       => reset_CD_local);

  reseter_2: entity work.reseter
    port map (
      clk         => clk_EVB,
      reset_async => reset_local,
      reset_sync  => '0',
      reset       => reset_EVB_local);
  
  -------------------------------------------------------------------------------
  -- CD clock domain
  -------------------------------------------------------------------------------   

  -------------------------------------------------------------------------------
  --Delay the convert signal to take into account the loop-back delay
  -------------------------------------------------------------------------------
--  monitor.convert_delay <= control.convert_delay;


  -- this passes a one clock pulse indicating that the RD_page has been updated
  pacd_1: entity work.pacd
    port map (
      iPulseA => readout_domain_RD_page_update,
      iClkA   => clk_EVB,
      iRSTAn  => '1',
      iClkB   => clk_CD,
      iRSTBn  => '1',
      oPulseB => capture_domain_RD_page_update);

  -- This process updates the capture clock domain's copy of the RD_page when
  -- an update pulse is sent from the readout clock domain
  capture_page: process (clk_CD) is    
  begin  -- process capture_index
    if clk_CD'event and clk_CD = '1' then  -- rising clock edge
      if reset_CD_local = '1' then      
        capture_domain_RD_page_copy <= RD_page_DEFAULT;
      else
        if capture_domain_RD_page_update = '1' then
--          capture_domain_RD_page_copy <= RD_page;
          capture_domain_RD_page_copy <= RD_page_avail;
        end if;
      end if;
    end if;
  end process capture_page;

  monitor.wait_window <= control.wait_window;
  monitor.enable <= control.enable;


  capture_state_machine: process (clk_CD) is
  begin  -- process capture_state_machine
    if clk_CD'event and clk_CD = '1' then  -- rising clock edge

      error_BUFFER_FULL <= '0';
      
      CD_delay <= COLDATA_stream;
      capture_domain_WR_page_update <= '0';      
      --State machine
      
      if ((reset_CD_local = '1') or --2017-11-14 replace "and" with an "or"
          (control.enable = '0')) then
        --Sync reset or diabled link
        capture_state <= CAP_STATE_INIT;
        WR_page <= WR_page_DEFAULT;
      else
        case capture_state is
          -------------------------------------------------------------
          when CAP_STATE_INIT =>
            --Wait for an idle character to be locked on
            capture_state <= CAP_STATE_INIT;
            if COLDATA_stream = IDLE_CHARACTER then
              --move on to parsing data
              capture_state <= CAP_STATE_IDLE;              
            end if;

            -- Since we just started, we don't need to update the wr page, so
            -- mark that as done
            wr_page_update_done <= '1';

            wait_for_first_real_trigger <= '1';
            
          -------------------------------------------------------------
          when CAP_STATE_IDLE =>
            --Keep monitoring idles
            capture_state <= CAP_STATE_IDLE;
--            if COLDATA_stream = SOF_CHARACTER then
--              capture_state <= CAP_STATE_START;              
--            end if;

            --If we have memory to write to and we get a SOF_CHARACTER, then
            --process the data
            if wr_page_update_done = '1' then
              if COLDATA_stream = SOF_CHARACTER then
                capture_state <= CAP_STATE_START;
              end if;
            else              
--              --Pulse the readout domain to start readout
--              if send_startup_pulse = '1' then
--                start_EVB_pulse_CDCLK <= '1';
--                send_startup_pulse <= '0'; -- mark that we've sent this pulse
--              end if;

              -- We haven't switched buffers yet, so try
              -- We need to switch buffers before we can do anything else
              capture_domain_WR_page_update <= '1';
              wr_page_update_done <= '1';


              if WR_page + 1 = Capture_Domain_RD_page_Copy then
                -- We can't switch buffers, so die
                error_BUFFER_FULL <= '1';
                capture_domain_WR_page_update <= '0';
                wr_page_update_done <= '0';
              else
                WR_page <= WR_page + 1;
              end if;


--2017-11-17-13-30--              if    WR_page = "00" and Capture_Domain_RD_page_Copy /= "01" then
--2017-11-17-13-30--                WR_page <= "01";
--2017-11-17-13-30--              elsif WR_page = "01" and Capture_Domain_RD_page_Copy /= "10" then
--2017-11-17-13-30--                WR_page <= "10";
--2017-11-17-13-30--              elsif WR_page = "10" and Capture_Domain_RD_page_Copy /= "11" then
--2017-11-17-13-30--                WR_page <= "11";
--2017-11-17-13-30--              elsif WR_page = "11" and Capture_Domain_RD_page_Copy /= "00" then
--2017-11-17-13-30--                WR_page <= "00";
--2017-11-17-13-30--              else
--2017-11-17-13-30--                -- We can't switch buffers, so die
--2017-11-17-13-30--                error_BUFFER_FULL <= '1';
--2017-11-17-13-30--                capture_domain_WR_page_update <= '0';
--2017-11-17-13-30--                wr_page_update_done <= '0';
--2017-11-17-13-30--              end if;            
            end if;
          -------------------------------------------------------------
          when CAP_STATE_START =>
            capture_state <= CAP_STATE_SKIP_WORD;
          -------------------------------------------------------------
          when CAP_STATE_SKIP_WORD =>
            capture_state <= CAP_STATE_PROCESS;
          -------------------------------------------------------------
          when CAP_STATE_PROCESS =>
            -- wr page update must have been done if we are here
            wr_page_update_done <= '0';

            capture_state <= CAP_STATE_PROCESS;
            
            if ((CDA_SWITCH = '0' and word_number = CDA_FRAME_SIZE-1) or
                (CDA_SWITCH = '1' and word_number = CDF_FRAME_SIZE-1)) then
              capture_state <= CAP_STATE_END;
              
              --2017-11-17-13-30--if    WR_page = "00" and Capture_Domain_RD_page_Copy /= "01" then
              --2017-11-17-13-30--  WR_page <= "01";
              --2017-11-17-13-30--elsif WR_page = "01" and Capture_Domain_RD_page_Copy /= "10" then
              --2017-11-17-13-30--  WR_page <= "10";
              --2017-11-17-13-30--elsif WR_page = "10" and Capture_Domain_RD_page_Copy /= "11" then
              --2017-11-17-13-30--  WR_page <= "11";
              --2017-11-17-13-30--elsif WR_page = "11" and Capture_Domain_RD_page_Copy /= "00" then
              --2017-11-17-13-30--  WR_page <= "00";
              --2017-11-17-13-30--else
              --2017-11-17-13-30--  -- We can't switch buffers, so die
              --2017-11-17-13-30--  error_BUFFER_FULL <= '1';
              --2017-11-17-13-30--  capture_domain_WR_page_update <= '0';
              --2017-11-17-13-30--  wr_page_update_done <= '0';
              --2017-11-17-13-30--end if;            

            end if;
          -------------------------------------------------------------
          when CAP_STATE_END =>
            capture_state <= CAP_STATE_IDLE;

            -- We are waiting for the first trigger with a timestamp of one.
            -- We would wait for one, but the FEMB always sends data, so the
            -- best we can do is hold it in timestamp reset 0x0000 and wait
            -- for us to release it to count.  This way it will give 0x0001
            -- and we know we should be recording
            if wait_for_first_real_trigger = '1' and stream_timestamp(to_integer(WR_page)) = x"0000" then
              -- Ignore this event, don't update WR Page
              
              -- Mark wri_page update as done since we aren't doing an update
              wr_page_update_done <= '1';
              
            else
              -- This is the first event to use in data taking, move to the
              -- normal data taking procedure. 
              wait_for_first_real_trigger <= '0';
              
              -- We haven't switched buffers yet, so try
              -- We need to switch buffers before we can do anything else
              capture_domain_WR_page_update <= '1';
              wr_page_update_done <= '1';
              
              if WR_page + 1 = Capture_Domain_RD_page_Copy then
                -- We can't switch buffers, so die
                error_BUFFER_FULL <= '1';
                capture_domain_WR_page_update <= '0';
                wr_page_update_done <= '0';
              else
                WR_page <= WR_page + 1;
                end if;                
              end if;   
                          
          -------------------------------------------------------------
          when others => capture_state <= CAP_STATE_INIT;
        end case;
      end if;      
    end if;
  end process capture_state_machine;

  
  
  capture_control: process (clk_CD) is
  begin  -- process capture_control
    if clk_CD'event and clk_CD = '1' then  -- rising clock edge

      --Error counter pule resets
      error_CONVERT_IN_WAIT_WINDOW <= '0';
      error_BAD_SOF <= '0';
      error_UNEXPECTED_EOF <= '0';
      error_MISSING_EOF <= '0';
      error_KCHAR_IN_DATA <= '0';
      error_BAD_CHSUM <= '0';

      pulse_packet_start <= '0';      

      data_in_wr <= '0';

      start_EVB_pulse_CDCLK <= '0';
      
      if reset_CD_local = '1' then 
--        send_startup_pulse <= '1'; --note that we need to send the startup pulse
      else
        case capture_state is
          -------------------------------------------------------------
          when CAP_STATE_INIT =>
            capture_idle_count <= CAPTURE_IDLE_COUNT_START;
          -------------------------------------------------------------
          when CAP_STATE_START => NULL;
          -------------------------------------------------------------
          when CAP_STATE_SKIP_WORD =>
            -- Start taking data
            pulse_packet_start <= '1';

            --Capture the current convert
            captured_convert(to_integer(WR_PAGE)) <= convert;
            
            data_errors(to_integer(WR_PAGE))(ERR_NOT_FINISHED) <= '0';
            
            word_number <= (others => '0');
            wr_address <= ADDR_CHECKSUM_1;    
            
            data_in_wr <= '1';


          -------------------------------------------------------------
          when CAP_STATE_PROCESS =>
            -----------------------------
            -- Check for bad words (errors)
            -----------------------------
            
            --Check if it is idle
            if CD_delay = IDLE_CHARACTER then
              --There was an idle word in the data part of the frame,
              --mark the event as not finished since it is short, but capture
              --the full count for debugging
              error_UNEXPECTED_EOF <= '1';
              data_errors(to_integer(WR_PAGE))(ERR_NOT_FINISHED) <= '1';
            end if;
            
            --check for a k-char in the data stream
            if CD_delay(8) = '1' then
              data_errors(to_integer(WR_PAGE))(ERR_K_IN_FRAME) <= '1';
              error_KCHAR_IN_DATA <= '1';
            end if;
            
            -----------------------------
            -- process the data word
            -----------------------------
            
            --Save incomming data to ram
            if ((CDA_SWITCH = '0' and word_number = CDA_FRAME_SIZE-1) or
                (CDA_SWITCH = '1' and word_number = CDF_FRAME_SIZE-1)) then
              --wr_address = FRAME_SIZE-1 then
              data_in_wr <= '0';
            else
              data_in_wr <= '1';
            end if;
            
            -- choose next RAM address
            --We either have real or FPGA COLDATA ASICs
            -- This will change slightly where and what data we save in the RAM
            if CDA_SWITCH = '0' then
              --Real coldata ASICS, so each stream has half the data and no redundancy
              case wr_address is
                when ADDR_CHECKSUM_1   => wr_address <= ADDR_CHECKSUM_2;
                when ADDR_CHECKSUM_2   => wr_address <= ADDR_TIMESTAMP;
                when ADDR_TIMESTAMP    => wr_address <= ADDR_ERRORS;
                when ADDR_ERRORS       => wr_address <= ADDR_RESERVED;
                when ADDR_RESERVED     => wr_address <= ADDR_ADC_HEADER_1;
                when ADDR_ADC_HEADER_1 => wr_address <= ADDR_ADC_HEADER_2;
                when ADDR_ADC_HEADER_2 => wr_address <= ADDR_DATA_START;
                when others            => wr_address <= wr_address + 1;
              end case;
            else
              --FPGA coldata ASICs, so we have redundancy in our time stamps,
              --errors and reserved words.  (also packing of data is
              --different, but the WIB doesn't care)
              if IS_LINK_A = '1' then
                --This is a link A, so what we want to stream out is the LSB
                --of redundant words
                case wr_address is
                  when ADDR_CHECKSUM_1   => wr_address <= ADDR_CHECKSUM_2;
                  when ADDR_CHECKSUM_2   => wr_address <= ADDR_TIMESTAMP;
                  when ADDR_TIMESTAMP    => wr_address <= ADDR_TIMESTAMP_R;
                  when ADDR_TIMESTAMP_R  => wr_address <= ADDR_ERRORS;
                  when ADDR_ERRORS       => wr_address <= ADDR_ERRORS_R;
                  when ADDR_ERRORS_R     => wr_address <= ADDR_RESERVED;
                  when ADDR_RESERVED     => wr_address <= ADDR_RESERVED_R;
                  when ADDR_RESERVED_R   => wr_address <= ADDR_ADC_HEADER_1;
                  when ADDR_ADC_HEADER_1 => wr_address <= ADDR_ADC_HEADER_2;
                  when ADDR_ADC_HEADER_2 => wr_address <= ADDR_DATA_START;
                  when others            => wr_address <= wr_address + 1;
                end case;                
              else
                --THis is a link B, so we want to stream out the MSB of
                --redundant words
                case wr_address is
                  when ADDR_CHECKSUM_1   => wr_address <= ADDR_CHECKSUM_2;
                  when ADDR_CHECKSUM_2   => wr_address <= ADDR_TIMESTAMP_R;
                  when ADDR_TIMESTAMP_R  => wr_address <= ADDR_TIMESTAMP;
                  when ADDR_TIMESTAMP    => wr_address <= ADDR_ERRORS_R;
                  when ADDR_ERRORS_R     => wr_address <= ADDR_ERRORS;
                  when ADDR_ERRORS       => wr_address <= ADDR_RESERVED_R;
                  when ADDR_RESERVED_R   => wr_address <= ADDR_RESERVED;
                  when ADDR_RESERVED     => wr_address <= ADDR_ADC_HEADER_1;
                  when ADDR_ADC_HEADER_1 => wr_address <= ADDR_ADC_HEADER_2;
                  when ADDR_ADC_HEADER_2 => wr_address <= ADDR_DATA_START;
                  when others            => wr_address <= wr_address + 1;
                end case;                
                
              end if;

              --update word number
              word_number <= word_number + 1;
              
              --update checksum
              if ( (CDA_SWITCH = '0' and word_number = CDA_WORD_COLDATA_CHECKSUM_MSB) or
                   (CDA_SWITCH = '1' and word_number = CDF_WORD_COLDATA_CHECKSUM_MSB)) then
                running_checksum <= x"0000";
              else
                running_checksum <= running_checksum + unsigned(CD_delay(7 downto 0)  );  
              end if;
              
              
              --Cache useful things for error checking
              if CDA_SWITCH = '0' then              
                case word_number is
                  when CDA_WORD_COLDATA_CHECKSUM_LSB =>
                    stream_checksum(to_integer(WR_page))( 7 downto 0)    <= unsigned(CD_delay(7 downto 0));   
                  when CDA_WORD_COLDATA_CHECKSUM_MSB =>
                    stream_checksum(to_integer(WR_page))(15 downto 8)    <= unsigned(CD_delay(7 downto 0));
                  when CDA_WORD_COLDATA_TIME         =>
                    if IS_LINK_A = '1' then
                      stream_timestamp(to_integer(WR_page))( 7 downto 0) <= CD_delay(7 downto 0);
                    else
                      stream_timestamp(to_integer(WR_page))(15 downto 8) <= CD_delay(7 downto 0);  
                    end if;                    
                  when CDA_WORD_COLDATA_ERRORS       =>
                    if IS_LINK_A = '1' then
                      stream_errors(to_integer(WR_page))( 7 downto 0)    <= CD_delay(7 downto 0);
                    else
                      stream_errors(to_integer(WR_page))(15 downto 8)    <= CD_delay(7 downto 0); 
                    end if;                    
                  when others => null;
                end case;
              else
                case word_number is
                  when CDF_WORD_COLDATA_CHECKSUM_LSB =>
                    stream_checksum(to_integer(WR_page))( 7 downto 0)  <= unsigned(CD_delay(7 downto 0));
                  when CDF_WORD_COLDATA_CHECKSUM_MSB =>
                    stream_checksum(to_integer(WR_page))(15 downto 8)  <= unsigned(CD_delay(7 downto 0));
                  when CDF_WORD_COLDATA_TIME_1       =>
                    stream_timestamp(to_integer(WR_page))( 7 downto 0) <= CD_delay(7 downto 0);
                  when CDF_WORD_COLDATA_TIME_2       =>
                    stream_timestamp(to_integer(WR_page))(15 downto 8) <= CD_delay(7 downto 0);
                  when CDF_WORD_COLDATA_ERRORS_1       =>
                    stream_errors(to_integer(WR_page))( 7 downto 0)    <= CD_delay(7 downto 0);
                  when CDF_WORD_COLDATA_ERRORS_2       =>
                    stream_errors(to_integer(WR_page))(15 downto 8)    <= CD_delay(7 downto 0);   
                  when others => null;
                end case;                
              end if;
            end if;           
          -------------------------------------------------------------
          when CAP_STATE_END =>
            --This is the word after the last word and should be an idle word
              
            --mark the data as finished (if it wasn't already set as not finished)
            --data_errors(WR_PAGE)(ERR_NOT_FINISHED) <= '0' or data_errors(WR_PAGE)(ERR_NOT_FINISHED);
            --compare the checksums and update the checksum error bit in the
            --capture errors
            if stream_checksum(to_integer(WR_PAGE)) = running_checksum then
              error_BAD_CHSUM <= '0';
              data_errors(to_integer(WR_PAGE))(ERR_CHSUM_BAD) <= '0';
            else
              error_BAD_CHSUM <= '1';
              data_errors(to_integer(WR_PAGE))(ERR_CHSUM_BAD) <= '1';
            end if;
            computed_checksum(to_integer(WR_page)) <= running_checksum;
            
            --Check that it ended correctly
            if CD_delay /= IDLE_CHARACTER then
              --The character after the 55 bytes wasn't an IDLE
              --force and end and mark it as bad
              data_errors(to_integer(WR_PAGE))(ERR_LARGE_FRAME) <= '1';
              error_MISSING_EOF <= '1';
            end if;
            
            --Get ready for the idle processing state
            capture_idle_count <= CAPTURE_IDLE_COUNT_START-1;

          -------------------------------------------------------------
          when CAP_STATE_IDLE =>
            --Update the idle count
            if capture_idle_count /= 0 then
              capture_idle_count <= capture_idle_count -1;
            end if;
              
            if CD_delay = SOF_CHARACTER then
              --WE should have a new packet when capture_idle_count is a 1, but
              --if we haven't gotten one by 0, we have an error and we go back
              --to INIT
              
              if capture_idle_count > 1 then
                --error, early SOF character
                --start taking data anyways
                error_CONVERT_IN_WAIT_WINDOW <= '1';                              
              end if;                                  
            elsif capture_idle_count = 0 then                                
              --We should have a SOF_CHARACTER now, so mark it bad if we don't
              error_BAD_SOF <= '1';
            end if;

          when others => capture_state <= CAP_STATE_INIT;
        end case;
      end if;        
    end if;
  end process capture_control;
















-- old  -- 256 byte RAM holding 4x64 bytes for 4 55byte events
  -- 1024 byte RAM holding 16x64 bytes for 16 55byte events
  COLDATA_RAM: CDRAM
    port map (
      data      => CD_delay(7 downto 0),--COLDATA_stream(7 downto 0),
      rdaddress => data_out_address,
      rdclock   => clk_EVB,
      wraddress => data_in_address,
      wrclock   => clk_CD,
      wren      => data_in_wr,
      q         => CD_to_EB_stream.data_out);
  --Build RAM address out of page number and page address
  data_out_address <= std_logic_vector(RD_page) & std_logic_vector(rd_address);
  data_in_address  <= std_logic_vector(WR_page) & std_logic_vector(wr_address);

  --Pass startup pulse from capture to readout time domains
  pacd_3: entity work.pacd
    port map (
      iPulseA => start_EVB_pulse_CDCLK,
      iClkA   => clk_CD,
      iRSTAn  => '1',
      iClkB   => clk_EVB,
      iRSTBn  => '1',
      oPulseB => start_EVB_pulse_EVBCLK);
  
  --Speeds up the access time to the ram by one clock tick over the clocked
  --process readout control
--  EB_readout_control: process (rd_address,readout_state,EB_rd) is
--  begin  -- process EB_readout_control
--    if (readout_state = RDOUT_STATE_CHECKING) then
--      if  EB_rd = '1' then
--        rd_address <= rd_address + 1;
--      else
--        -- Set readout pipeline to the beginning
--        rd_address <= (others => '0');        
--      end if;      
--    elsif (readout_state = RDOUT_STATE_READING) then
--      if rd_address <= (ADDR_DATA_END(5 downto 2)) then
--        rd_address <= rd_address + 1;
--      end if;
--    else
--      -- Set readout pipeline to the beginning
--      rd_address <= (others => '0');              
--    end if;
--  end process EB_readout_control;

  -------------------------------------------------------------------------------
  -- Event builder clock domain
  -------------------------------------------------------------------------------   

  -- this passes a one clock pulse indicating that the WR_page has been updated
  pacd_2: entity work.pacd
    port map (
      iPulseA => capture_domain_WR_page_update,
      iClkA   => clk_CD,
      iRSTAn  => '1',
      iClkB   => clk_EVB,
      iRSTBn  => '1',
      oPulseB => readout_domain_WR_page_update);


  
  -- This process updates the readout clock domain's copy of the WR_page when
  -- an update pulse is sent from the capture clock domain
  readout_page: process (clk_EVB) is    
  begin  -- process capture_index
    if clk_EVB'event and clk_EVB = '1' then  -- rising clock edge
      if reset_EVB_local = '1' then  
        readout_domain_WR_page_copy <= WR_page_DEFAULT;
      else   
        if readout_domain_WR_page_update = '1' then
          readout_domain_WR_page_copy <= WR_page;
        end if;
      end if;
    end if;
  end process readout_page;

  
  
  readout_startup_delay: process (clk_EVB) is
  begin  -- process readout_startup_delay
    if clk_EVB'event and clk_EVB = '1' then  -- rising clock edge
      -- counter to wait
      if reset_EVB_local = '1' then
        enable_readout <= '0';
        readout_delay_countdown <= READOUT_DELAY_COUNTDOWN_START;
      else
        if or_reduce(std_logic_vector(readout_delay_countdown)) = '0' then
          --We have waited long enough, start reading out captured data
          -- This is here to put the readout data out of phase with the
          -- captured data
          enable_readout <= '1';
        elsif readout_delay_countdown = READOUT_DELAY_COUNTDOWN_START then
          -- On startup, we will be at READOUT_DELAY_COUNTDOWN_START and we
          -- will hold here until we get a pulse from the capture domain
          if start_EVB_pulse_EVBCLK = '1' then
            -- Start the countdown
            readout_delay_countdown <= readout_delay_countdown -1;
          end if;
        else
          -- Countdown until we get to zero
          readout_delay_countdown <= readout_delay_countdown -1;
        end if;
      end if;
    end if;
  end process readout_startup_delay;
  

  readout_control: process (clk_EVB) is
  begin  -- process readout_control
    if clk_EVB'event and clk_EVB = '1' then  -- rising clock edge
      if reset_EVB_local = '1'  then
        RD_page <= RD_page_DEFAULT;
        RD_page_avail <= RD_page_DEFAULT;
        readout_state <= RDOUT_STATE_IDLE;        
      else        
        readout_domain_RD_page_update <= '0';
        
        case readout_state is
          when RDOUT_STATE_IDLE =>

            --Jump to checking state if there is a new valid page
            readout_state <= RDOUT_STATE_WAIT  ;

            if RD_page + 1 = readout_Domain_WR_page_Copy then
              -- If no new data, stay in idle
              readout_state <= RDOUT_STATE_IDLE;
            else
              -- move to the next page
              RD_page <= RD_page + 1;
              RD_page_avail <= RD_page + 1;
              readout_domain_RD_page_update <= '1';

              --Present the next frame's data

              --Mark frame as valid
              CD_to_EB_stream.valid <= '1';
              
              -- Present the COLDATA errors and the timestamp
              CD_to_EB_stream.CD_errors <= stream_errors(to_integer(RD_page+1));
              CD_to_EB_stream.CD_timestamp <= stream_timestamp(to_integer(RD_page+1));
              
              --Present the captured errors (from the WR side)
              CD_to_EB_stream.capture_errors <= data_errors(to_integer(RD_page+1));              

              --set for readout
              rd_address <= ADDR_PADDING(5 downto 2);   -- Move back a state
            end if;

          when RDOUT_STATE_WAIT =>            
            if EB_rd = '1' then
              readout_state <= RDOUT_STATE_READING;
              rd_address <= rd_address + 1;
            end if;
            
          when RDOUT_STATE_READING =>
            -- since we are reading out this data, it should not longer be
            -- marked as valid
            CD_to_EB_stream.valid <= '0';
            
            rd_address <= rd_address + 1;
            -- reading data, waiting for data to be all read out
            if rd_address = (ADDR_DATA_END(5 downto 2)) then
              --we are done, move to wait state if we can (ie. data is ready)
              -- or go into idle if we aren't ready yet
              
              if RD_page + 1 = readout_Domain_WR_page_Copy then
                -- If no new data, stay in idle
                readout_state <= RDOUT_STATE_IDLE;
              else
                readout_state <= RDOUT_STATE_WAIT;
                -- move to the next page
                RD_page <= RD_page + 1;
                RD_page_avail <= RD_page + 1;
                readout_domain_RD_page_update <= '1';
                
                --Present the next frame's data
                
                --Mark frame as valid
                CD_to_EB_stream.valid <= '1';
                
                -- Present the COLDATA errors and the timestamp
                CD_to_EB_stream.CD_errors <= stream_errors(to_integer(RD_page+1));
                CD_to_EB_stream.CD_timestamp <= stream_timestamp(to_integer(RD_page+1));
                
                --Present the captured errors (from the WR side)
                CD_to_EB_stream.capture_errors <= data_errors(to_integer(RD_page+1));              
                
                --set for readout
                rd_address <= ADDR_PADDING(5 downto 2);   -- Move back a state
              end if;
                
            end if;
            


            --readout_state <= RDOUT_STATE_IDLE;
            
            -- Since we are near the end of this page, we can mark it as available
--            if rd_address = (ADDR_DATA_END(5 downto 2) - 10) then
--              -- poll for next open page with valid data
--              RD_page_avail <= RD_page + 1;              
--              readout_domain_RD_page_update <= '1'; --update the other clock domain
--            end if;
            
          when others => readout_state <= RDOUT_STATE_IDLE;
        end case;
      end if;
    end if;
  end process readout_control;
























  
  -------------------------------------------------------------------------------
  -- Counters
  -------------------------------------------------------------------------------   
  counter_1: entity work.counter
    port map (
      clk         => clk_CD,
      reset_async => '0',
      reset_sync  => control.reset_counter_buffer_full,
      enable      => '1',
      event       => error_BUFFER_FULL,
      count       => monitor.counter_buffer_full,
      at_max      => open);
  counter_2: entity work.counter
    port map (
      clk         => clk_CD,
      reset_async => '0',
      reset_sync  => control.reset_counter_convert_in_wait_window,
      enable      => '1',
      event       => error_CONVERT_IN_WAIT_WINDOW,
      count       => monitor.counter_convert_in_wait_window,
      at_max      => open);
  counter_3: entity work.counter
    port map (
      clk         => clk_CD,
      reset_async => '0',
      reset_sync  => control.reset_counter_BAD_SOF,
      enable      => '1',
      event       => error_BAD_SOF,
      count       => monitor.counter_BAD_SOF,
      at_max      => open);
  counter_4: entity work.counter
    port map (
      clk         => clk_CD,
      reset_async => '0',
      reset_sync  => control.reset_counter_UNEXPECTED_EOF,
      enable      => '1',
      event       => error_UNEXPECTED_EOF,
      count       => monitor.counter_UNEXPECTED_EOF,
      at_max      => open);
  counter_5: entity work.counter
    port map (
      clk         => clk_CD,
      reset_async => '0',
      reset_sync  => control.reset_counter_MISSING_EOF,
      enable      => '1',
      event       => error_MISSING_EOF,
      count       => monitor.counter_MISSING_EOF,
      at_max      => open);
  counter_6: entity work.counter
    port map (
      clk         => clk_CD,
      reset_async => '0',
      reset_sync  => control.reset_counter_KCHAR_IN_DATA,
      enable      => '1',
      event       => error_KCHAR_IN_DATA,
      count       => monitor.counter_KCHAR_IN_DATA,
      at_max      => open);
  counter_7: entity work.counter
    port map (
      clk         => clk_CD,
      reset_async => '0',
      reset_sync  => control.reset_counter_BAD_CHSUM,
      enable      => '1',
      event       => error_BAD_CHSUM,
      count       => monitor.counter_BAD_CHSUM,
      at_max      => open);
  counter_8: entity work.counter
    port map (
      clk         => clk_CD,
      reset_async => '0',
      reset_sync  => control.reset_counter_packets,
      enable      => '1',
      event       => pulse_packet_start,
      count       => monitor.counter_packets,
      at_max      => open);
  
end architecture behavioral;
